<section>
<div id="content">
<strong>前言：<br></strong>php4中引入了foreach结构，这是一种遍历数组的简单方式。相比传统的for循环，foreach能够更加便捷的获取键值对。在php5之前，foreach仅能用于数组；php5之后，利用foreach还能遍历对象（详见：遍历对象）。本文中仅讨论遍历数组的情况。<br><br>foreach虽然简单，不过它可能会出现一些意外的行为，特别是代码涉及引用的情况下。<br>下面列举了几种case，有助于我们进一步认清foreach的本质。<br><strong>问题1：<br></strong><div class="codetitle"> 代码如下:</div><code class="codebody" id="code65369"><br>$arr = array(1,2,3);<br>foreach($arr as $k =&gt; &amp;$v) {<br>&nbsp;&nbsp;&nbsp; $v = $v * 2;<br>}<br>// now $arr is array(2, 4, 6)<br>foreach($arr as $k =&gt; $v) {<br>&nbsp;&nbsp;&nbsp; echo "$k", " =&gt; ", "$v";<br>}<br></code><br>先从简单的开始，如果我们尝试运行上述代码，就会发现最后输出为0=&gt;2&nbsp; 1=&gt;4&nbsp; 2=&gt;4 。<br>为何不是0=&gt;2&nbsp; 1=&gt;4&nbsp; 2=&gt;6 ？<br>其实，我们可以认为 foreach($arr as $k =&gt; $v) 结构隐含了如下操作，分别将数组当前的'键'和当前的'值'赋给变量$k和$v。具体展开形如：<br><div class="codetitle"><span> 代码如下:</div><code class="codebody" id="code57083"><br>foreach($arr as $k =&gt; $v){ <br>&nbsp;&nbsp;&nbsp; //在用户代码执行之前隐含了2个赋值操作<br>&nbsp;&nbsp;&nbsp; $v = currentVal(); <br>&nbsp;&nbsp;&nbsp; $k = currentKey();<br>&nbsp;&nbsp;&nbsp; //继续运行用户代码<br>&nbsp;&nbsp;&nbsp; ……<br>}<br></code><br>根据上述理论，现在我们重新来分析下第一个foreach：<br>第1遍循环，由于$v是一个引用，因此$v = &amp;$arr[0]，$v=$v*2相当于$arr[0]*2，因此$arr变成2,2,3<br>第2遍循环，$v = &amp;$arr[1]，$arr变成2,4,3<br>第3遍循环，$v = &amp;$arr[2]，$arr变成2,4,6<br><strong>随后代码进入了第二个foreach：<br></strong>第1遍循环，隐含操作$v=$arr[0]被触发，由于此时$v仍然是$arr[2]的引用，即相当于$arr[2]=$arr[0]，$arr变成2,4,2<br>第2遍循环，$v=$arr[1]，即$arr[2]=$arr[1]，$arr变成2,4,4<br>第3遍循环，$v=$arr[2]，即$arr[2]=$arr[2]，$arr变成2,4,4<br>OK，分析完毕。<br><strong>如何解决类似问题呢？php手册上有一段提醒：<br></strong><font style="COLOR: #ff0000">Warning : 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用unset()来将其销毁。<br></font><div class="codetitle"> 代码如下:</div><code class="codebody" id="code35057"><br>$arr = array(1,2,3);<br>foreach($arr as $k =&gt; &amp;$v) {<br>&nbsp;&nbsp;&nbsp; $v = $v * 2;<br>}<br>unset($v);<br>foreach($arr as $k =&gt; $v) {<br>&nbsp;&nbsp;&nbsp; echo "$k", " =&gt; ", "$v";<br>}<br>// 输出 0=&gt;2&nbsp; 1=&gt;4&nbsp; 2=&gt;6<br></code><br>从这个问题中我们可以看出，引用很有可能会伴随副作用。如果不希望无意识的修改导致数组内容变更，最好及时unset掉这些引用。<br><strong>问题2：<br></strong><div class="codetitle"> 代码如下:</div><code class="codebody" id="code74578"><br>$arr = array('a','b','c');<br>foreach($arr as $k =&gt; $v) {<br>&nbsp;&nbsp;&nbsp; echo key($arr), "=&gt;", current($arr);<br>}<br>// 打印 1=&gt;b 1=&gt;b 1=&gt;b<br></code><br>这个问题更加诡异。按照手册的说法，key和current分别是取数组中当前元素的的键值。<br>那为何key($arr)一直是1，current($arr)一直是b呢?<br>先用vld查看编译之后的opcode:<img alt="" src="images/10/201306300929563.png" width="633" height="370"><br><style type="text/css" media="screen" id="s-f21ac82b21eeb7322631b6aa94e17f451v92atc">.imageplus-append-lu-img-txt{overflow:hidden;margin:10px 0}.imageplus-append-nova-txt{border:1px solid #f2f2f2;box-sizing:border-box;font-family:Microsoft YaHei;line-height:normal}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item{position:relative;width:100%;height:50px;background-color:#fff}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item a{text-decoration:none}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item a:hover{text-decoration:underline}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item div{word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:auto;height:25px;line-height:25px;margin:0 16px;font-weight:normal}
.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title span{font-size:14px;font-weight:bold;color:#003397}
.imageplus-append-nova-txt-ue2{font-family:Microsoft YaHei;float:left;border:1px solid #ddd;border-top:3px solid #ff2f62;background-color:#f9f9f9}.imageplus-append-nova-txt-ue2 a:focus{outline:0}.imageplus-append-nova-txt-ue2 .imageplus-append-content{float:left}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item{margin-left:44px;height:60px;padding-top:5px;padding-bottom:5px}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item a{text-decoration:none}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item div{word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title{height:30px;line-height:30px;font-size:16px}
.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title a{color:#000}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-true{float:left}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-click{float:left;width:96px}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-click a{color:#ff2f62}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc{height:26px;line-height:26px;font-size:12px}
.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc a{color:#7b7b7b}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn{float:right;margin-top:19px;margin-right:18px}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn a{text-decoration:none}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn div{width:100px;height:32px;line-height:32px;text-align:center;background-color:#ff2f62;border:0;-webkit-border-radius:16px;-moz-border-radius:16px;border-radius:16px;color:#fff;font-family:Microsoft YaHei;font-size:16px;cursor:pointer}.imageplus-append-nova-txt-ue2 .imageplus-append-jian{position:absolute;top:3px;left:10px;width:22px;height:40px;background-image:url(http://ecma.bdimg.com/public03/imageplus/append/nova_txt_star_160426.png);background-position:0 0;background-repeat:no-repeat}
.imageplus-append-nova-txt-ue2 .imageplus-append-close-btn{display:none}.imageplus-append-nova-txt-ue2 .imageplus-append-logo{display:none}.imageplus-append-nova-txt-ue2 .imageplus-baidu-logo{position:absolute;bottom:0;right:0;z-index:9999;background:url(http://ecma.bdimg.com/public03/imageplus/logo.png) no-repeat;background-position:0 -17px;width:16px;height:16px}.imageplus-append-nova-txt-ue2 .imageplus-ad-logo{position:absolute;left:0;bottom:0;overflow:hidden;z-index:12;background:url(http://ecma.bdimg.com/public03/imageplus/logo.png) no-repeat;background-position:0 0;width:34px;height:16px}.imageplus-append{float:none;margin:0;padding:0;border:0;overflow:hidden;position:static;display:block;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;position:relative;text-indent:0;display:inline-block}
.imageplus-append div{float:none;margin:0;padding:0;border:0;overflow:hidden;position:static;display:block;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;font-family:Microsoft YaHei;line-height:normal}.imageplus-append a,.imageplus-append img,.imageplus-append span{float:none;margin:0;padding:0;border:0;overflow:visible;position:static;display:inline;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;font-family:Microsoft YaHei;line-height:normal}</style><div class="imageplus-append" id="f21ac82b21eeb7322631b6aa94e17f451v92atc" data-rendered="true" style="margin: 0px auto 0px 0px; padding: 0px; border: none; width: 637px;"><div class="imageplus-append-box" id="w-bhzke8">
<div id="w-bhzke8-widget-isolated-host" style="overflow:visible;box-sizing:content-box;position:static;display:block;padding:0;margin:0;border:none;"></div>
</div></div><br><br><br>我们从第3行的ASSIGN指令看起，它代表将array('a','b','c')赋值给$arr。<br>由于$arr为CV，array('a','b','c')为TMP，因此ASSIGN指令找到实际执行的函数为ZEND_ASSIGN_SPEC_CV_TMP_HANDLER。这里需要特别指出，CV是PHP5.1之后才增加的一种变量cache，它采用数组的形式来保存zval**，被cache住的变量再次使用时无需去查找active符号表，而是直接去CV数组中获取，由于数组访问速度远超hash表，因而可以提高效率。<br><div class="codetitle"> 代码如下:</div><code class="codebody" id="code56015"><br>static int ZEND_FASTCALL&nbsp; ZEND_ASSIGN_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>&nbsp;&nbsp;&nbsp; zend_op *opline = EX(opline);<br>&nbsp;&nbsp;&nbsp; zend_free_op free_op2;<br>&nbsp;&nbsp;&nbsp; zval *value = _get_zval_ptr_tmp(&amp;opline-&gt;op2, EX(Ts), &amp;free_op2 TSRMLS_CC);<br><br>&nbsp;&nbsp;&nbsp; // CV数组中创建出$arr**指针<br>&nbsp;&nbsp;&nbsp; zval **variable_ptr_ptr = _get_zval_ptr_ptr_cv(&amp;opline-&gt;op1, EX(Ts), BP_VAR_W TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp; if (IS_CV == IS_VAR &amp;&amp; !variable_ptr_ptr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将array赋值给$arr<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = zend_assign_to_variable(variable_ptr_ptr, value, 1 TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!RETURN_VALUE_UNUSED(&amp;opline-&gt;result)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AI_SET_PTR(EX_T(opline-&gt;result.u.var).var, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PZVAL_LOCK(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ZEND_VM_NEXT_OPCODE();<br>}<br></code><br>ASSIGN指令完成之后，CV数组中被加入zval**指针，指针指向实际的array，这表示$arr已经被CV缓存了起来。<img alt="" src="images/10/201306300929564.png" width="559" height="223"><br><style type="text/css" media="screen" id="s-f21ac82b21eeb7322631b6aa94e17f4524pp7r4">.imageplus-append-lu-img-txt{overflow:hidden;margin:10px 0}.imageplus-append-nova-txt{border:1px solid #f2f2f2;box-sizing:border-box;font-family:Microsoft YaHei;line-height:normal}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item{position:relative;width:100%;height:50px;background-color:#fff}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item a{text-decoration:none}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item a:hover{text-decoration:underline}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item div{word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:auto;height:25px;line-height:25px;margin:0 16px;font-weight:normal}
.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title span{font-size:14px;font-weight:bold;color:#003397}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc span{font-size:12px;color:#333}.imageplus-append-jian{width:20px;height:20px;background-image:url(http://ecmb.bdimg.com/public03/imageplus_m_append_jian_151204.png);background-repeat:no-repeat;background-position:0 0;position:absolute;top:0;left:0}.imageplus-append-close-btn{width:40px;height:40px;position:absolute;right:0;top:0;background-image:url(http://ecmb.bdimg.com/public03/imageplus_m_append_close_btn_151113.png);background-repeat:no-repeat;background-position:0 0;display:none}.imageplus-append-logo{height:18px;width:18px;background:url(http://cpro.baidustatic.com/cpro/ui/noexpire/img/2.0.1/bg.png) no-repeat left top;position:absolute;right:0;bottom:0}
.imageplus-append-nova-txt-ue2{font-family:Microsoft YaHei;float:left;border:1px solid #ddd;border-top:3px solid #ff2f62;background-color:#f9f9f9}.imageplus-append-nova-txt-ue2 a:focus{outline:0}.imageplus-append-nova-txt-ue2 .imageplus-append-content{float:left}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item{margin-left:44px;height:60px;padding-top:5px;padding-bottom:5px}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item a{text-decoration:none}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item div{word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title{height:30px;line-height:30px;font-size:16px}
.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title a{color:#000}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-true{float:left}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-click{float:left;width:96px}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-click a{color:#ff2f62}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc{height:26px;line-height:26px;font-size:12px}
.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc a{color:#7b7b7b}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn{float:right;margin-top:19px;margin-right:18px}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn a{text-decoration:none}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn div{width:100px;height:32px;line-height:32px;text-align:center;background-color:#ff2f62;border:0;-webkit-border-radius:16px;-moz-border-radius:16px;border-radius:16px;color:#fff;font-family:Microsoft YaHei;font-size:16px;cursor:pointer}.imageplus-append-nova-txt-ue2 .imageplus-append-jian{position:absolute;top:3px;left:10px;width:22px;height:40px;background-image:url(http://ecma.bdimg.com/public03/imageplus/append/nova_txt_star_160426.png);background-position:0 0;background-repeat:no-repeat}
.imageplus-append-nova-txt-ue2 .imageplus-append-close-btn{display:none}.imageplus-append-nova-txt-ue2 .imageplus-append-logo{display:none}.imageplus-append-nova-txt-ue2 .imageplus-baidu-logo{position:absolute;bottom:0;right:0;z-index:9999;background:url(http://ecma.bdimg.com/public03/imageplus/logo.png) no-repeat;background-position:0 -17px;width:16px;height:16px}.imageplus-append-nova-txt-ue2 .imageplus-ad-logo{position:absolute;left:0;bottom:0;overflow:hidden;z-index:12;background:url(http://ecma.bdimg.com/public03/imageplus/logo.png) no-repeat;background-position:0 0;width:34px;height:16px}.imageplus-append{float:none;margin:0;padding:0;border:0;overflow:hidden;position:static;display:block;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;position:relative;text-indent:0;display:inline-block}
.imageplus-append div{float:none;margin:0;padding:0;border:0;overflow:hidden;position:static;display:block;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;font-family:Microsoft YaHei;line-height:normal}.imageplus-append a,.imageplus-append img,.imageplus-append span{float:none;margin:0;padding:0;border:0;overflow:visible;position:static;display:inline;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;font-family:Microsoft YaHei;line-height:normal}</style><div class="imageplus-append" id="f21ac82b21eeb7322631b6aa94e17f4524pp7r4" data-rendered="true" style="margin: 0px auto 0px 0px; padding: 0px; border: none; width: 563px;"><div class="imageplus-append-box" id="w-yrqke9">
<div id="w-yrqke9-widget-isolated-host" style="overflow:visible;box-sizing:content-box;position:static;display:block;padding:0;margin:0;border:none;"></div>
</div></div><br><br><br>接下来执行数组的循环操作，我们来看FE_RESET指令，它对应的执行函数为<strong>ZEND_FE_RESET_SPEC_CV_HANDLER：<br></strong><div class="codetitle"> 代码如下:</div><code class="codebody" id="code38261"><br>static int ZEND_FASTCALL&nbsp; ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; if (……) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过CV数组获取指向array的指针<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr = _get_zval_ptr_cv(&amp;opline-&gt;op1, EX(Ts), BP_VAR_R TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; // 将指向array的指针保存到zend_execute_data-&gt;Ts中(Ts用于存放代码执行期的temp_variable)<br>&nbsp;&nbsp;&nbsp; AI_SET_PTR(EX_T(opline-&gt;result.u.var).var, array_ptr);<br>&nbsp;&nbsp;&nbsp; PZVAL_LOCK(array_ptr);<br>&nbsp;&nbsp;&nbsp; if (iter) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; } else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 重置数组内部指针<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_internal_pointer_reset(fe_ht);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ce) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 设置EX_T(opline-&gt;result.u.var).fe.fe_pos用于保存数组内部指针<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_get_pointer(fe_ht, &amp;EX_T(opline-&gt;result.u.var).fe.fe_pos);<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ……<br>}<br></code><br>这里主要将2个重要的指针存入了zend_execute_data-&gt;Ts中:<br><font style="COLOR: #ff0000">•EX_T(opline-&gt;result.u.var).var ---- 指向array的指针<br>•EX_T(opline-&gt;result.u.var).fe.fe_pos ---- 指向array内部元素的指针<br></font>FE_RESET指令执行完毕之后，内存中实际情况如下：<br>
<p><img alt="" src="images/10/201306300929565.png" width="581" height="302"><br><style type="text/css" media="screen" id="s-f21ac82b21eeb7322631b6aa94e17f4532da20b">.imageplus-append-lu-img-txt{overflow:hidden;margin:10px 0}.imageplus-append-nova-txt{border:1px solid #f2f2f2;box-sizing:border-box;font-family:Microsoft YaHei;line-height:normal}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item{position:relative;width:100%;height:50px;background-color:#fff}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item a{text-decoration:none}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item a:hover{text-decoration:underline}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item div{word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:auto;height:25px;line-height:25px;margin:0 16px;font-weight:normal}
.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title span{font-size:14px;font-weight:bold;color:#003397}.imageplus-append-nova-txt .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc span{font-size:12px;color:#333}.imageplus-append-jian{width:20px;height:20px;background-image:url(http://ecmb.bdimg.com/public03/imageplus_m_append_jian_151204.png);background-repeat:no-repeat;background-position:0 0;position:absolute;top:0;left:0}.imageplus-append-close-btn{width:40px;height:40px;position:absolute;right:0;top:0;background-image:url(http://ecmb.bdimg.com/public03/imageplus_m_append_close_btn_151113.png);background-repeat:no-repeat;background-position:0 0;display:none}.imageplus-append-logo{height:18px;width:18px;background:url(http://cpro.baidustatic.com/cpro/ui/noexpire/img/2.0.1/bg.png) no-repeat left top;position:absolute;right:0;bottom:0}
.imageplus-append-nova-txt-ue2{font-family:Microsoft YaHei;float:left;border:1px solid #ddd;border-top:3px solid #ff2f62;background-color:#f9f9f9}.imageplus-append-nova-txt-ue2 a:focus{outline:0}.imageplus-append-nova-txt-ue2 .imageplus-append-content{float:left}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item{margin-left:44px;height:60px;padding-top:5px;padding-bottom:5px}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item a{text-decoration:none}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item div{word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title{height:30px;line-height:30px;font-size:16px}
.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title a{color:#000}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-true{float:left}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-click{float:left;width:96px}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-title .imageplus-append-nova-txt-title-click a{color:#ff2f62}.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc{height:26px;line-height:26px;font-size:12px}
.imageplus-append-nova-txt-ue2 .imageplus-append-content .imageplus-append-nova-txt-ad-item .imageplus-append-nova-txt-ad-item-desc a{color:#7b7b7b}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn{float:right;margin-top:19px;margin-right:18px}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn a{text-decoration:none}.imageplus-append-nova-txt-ue2 .imageplus-append-go-btn div{width:100px;height:32px;line-height:32px;text-align:center;background-color:#ff2f62;border:0;-webkit-border-radius:16px;-moz-border-radius:16px;border-radius:16px;color:#fff;font-family:Microsoft YaHei;font-size:16px;cursor:pointer}.imageplus-append-nova-txt-ue2 .imageplus-append-jian{position:absolute;top:3px;left:10px;width:22px;height:40px;background-image:url(http://ecma.bdimg.com/public03/imageplus/append/nova_txt_star_160426.png);background-position:0 0;background-repeat:no-repeat}
.imageplus-append-nova-txt-ue2 .imageplus-append-close-btn{display:none}.imageplus-append-nova-txt-ue2 .imageplus-append-logo{display:none}.imageplus-append-nova-txt-ue2 .imageplus-baidu-logo{position:absolute;bottom:0;right:0;z-index:9999;background:url(http://ecma.bdimg.com/public03/imageplus/logo.png) no-repeat;background-position:0 -17px;width:16px;height:16px}.imageplus-append-nova-txt-ue2 .imageplus-ad-logo{position:absolute;left:0;bottom:0;overflow:hidden;z-index:12;background:url(http://ecma.bdimg.com/public03/imageplus/logo.png) no-repeat;background-position:0 0;width:34px;height:16px}.imageplus-append{float:none;margin:0;padding:0;border:0;overflow:hidden;position:static;display:block;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;position:relative;text-indent:0;display:inline-block}
.imageplus-append div{float:none;margin:0;padding:0;border:0;overflow:hidden;position:static;display:block;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;font-family:Microsoft YaHei;line-height:normal}.imageplus-append a,.imageplus-append img,.imageplus-append span{float:none;margin:0;padding:0;border:0;overflow:visible;position:static;display:inline;visibility:visible;text-align:left;background:transparent;-webkit-box-sizing:content-box;box-sizing:content-box;font-family:Microsoft YaHei;line-height:normal}</style><div class="imageplus-append" id="f21ac82b21eeb7322631b6aa94e17f4532da20b" data-rendered="true" style="margin: 0px auto 0px 0px; padding: 0px; border: none; width: 585px;"><div class="imageplus-append-box" id="w-kxo916">
<div id="w-kxo916-widget-isolated-host" style="overflow:visible;box-sizing:content-box;position:static;display:block;padding:0;margin:0;border:none;"></div>
</div></div><br><br><br>接下来我们继续查看FE_FETCH，它对应的执行函数为ZEND_FE_FETCH_SPEC_VAR_HANDLER：<br></p><div class="codetitle"> 代码如下:</div><code class="codebody" id="code64965"><br>static int ZEND_FASTCALL&nbsp; ZEND_FE_FETCH_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>&nbsp;&nbsp;&nbsp; zend_op *opline = EX(opline);<br><br>&nbsp;&nbsp;&nbsp; // 注意指针是从EX_T(opline-&gt;op1.u.var).var.ptr获取的<br>&nbsp;&nbsp;&nbsp; zval *array = EX_T(opline-&gt;op1.u.var).var.ptr;<br>&nbsp;&nbsp;&nbsp; ……<br><br>&nbsp;&nbsp;&nbsp; switch (zend_iterator_unwrap(array, &amp;iter TSRMLS_CC)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_INVALID:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_PLAIN_OBJECT: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_PLAIN_ARRAY:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fe_ht = HASH_OF(array);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 特别注意：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FE_RESET指令中将数组内部元素的指针保存在EX_T(opline-&gt;op1.u.var).fe.fe_pos<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 此处获取该指针<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_set_pointer(fe_ht, &amp;EX_T(opline-&gt;op1.u.var).fe.fe_pos);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取元素的值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (zend_hash_get_current_data(fe_ht, (void **) &amp;value)==FAILURE) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEND_VM_JMP(EX(op_array)-&gt;opcodes+opline-&gt;op2.u.opline_num);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (use_key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_type = zend_hash_get_current_key_ex(fe_ht, &amp;str_key, &amp;str_key_len, &amp;int_key, 1, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 数组内部指针移动到下一个元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_move_forward(fe_ht);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 移动之后的指针保存到EX_T(opline-&gt;op1.u.var).fe.fe_pos<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_get_pointer(fe_ht, &amp;EX_T(opline-&gt;op1.u.var).fe.fe_pos);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_OBJECT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; ……<br>}<br></code><br>根据FE_FETCH的实现，我们大致上明白了foreach($arr as $k =&gt; $v)所做的事情。它会根据zend_execute_data-&gt;Ts的指针去获取数组元素，在获取成功之后，将该指针移动到下一个位置再重新保存。<p></p>
<p><img alt="" src="images/10/201306300929566.png" width="593" height="302"><br><div class="imageplus-append" id="f21ac82b21eeb7322631b6aa94e17f454xo0ofe" data-rendered="true" style="margin: 0px auto 0px 0px; padding: 0px; border: none; width: 597px;"><div class="imageplus-append-box" id="w-dd8i8u">
<div id="w-dd8i8u-widget-isolated-host" style="overflow:visible;box-sizing:content-box;position:static;display:block;padding:0;margin:0;border:none;"></div>
</div></div><br></p>
<p>简单来说，由于第一遍循环中FE_FETCH中已经将数组的内部指针移动到了第二个元素，所以在foreach内部调用key($arr)和current($arr)时，实际上获取的便是1和'b'。<br><strong>那为何会输出3遍1=&gt;b呢？<br></strong>我们继续看第9行和第13行的SEND_REF指令，它表示将$arr参数压栈。紧接着一般会使用DO_FCALL指令去调用key和current函数。PHP并非被编译成本地机器码，因此php采用这样的opcode指令去模拟实际CPU和内存的工作方式。<br><strong>查阅PHP源码中的SEND_REF：<br></strong></p><div class="codetitle"> 代码如下:</div><code class="codebody" id="code84855"><br>static int ZEND_FASTCALL&nbsp; ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; // 从CV中获取$arr指针的指针<br>&nbsp;&nbsp;&nbsp; varptr_ptr = _get_zval_ptr_ptr_cv(&amp;opline-&gt;op1, EX(Ts), BP_VAR_W TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp; ……<br><br>&nbsp;&nbsp;&nbsp; // 变量分离，此处重新copy了一份array专门用于key函数<br>&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);<br>&nbsp;&nbsp;&nbsp; varptr = *varptr_ptr;<br>&nbsp;&nbsp;&nbsp; Z_ADDREF_P(varptr);<br><br>&nbsp;&nbsp;&nbsp; // 压栈<br>&nbsp;&nbsp;&nbsp; zend_vm_stack_push(varptr TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp; ZEND_VM_NEXT_OPCODE();<br>}<br></code><br>上述代码中的SEPARATE_ZVAL_TO_MAKE_IS_REF是一个宏：<br><div class="codetitle"> 代码如下:</div><code class="codebody" id="code51743"><br>#define SEPARATE_ZVAL_TO_MAKE_IS_REF(ppzv)&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp; if (!PZVAL_IS_REF(*ppzv)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL(ppzv);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_ISREF_PP((ppzv));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp; }<br></code><br>SEPARATE_ZVAL_TO_MAKE_IS_REF的主要作用为，如果变量不是一个引用，则在内存中copy出一份新的。本例中它将array('a','b','c')复制了一份。因此变量分离之后的内存为：<a href="images/10/201306300929567.png" target="_blank" class="bPic"><img alt="" src="images/10/201306300929567.png" width="658" height="300" style="width: 650px; height: auto;"></a><br>注意，变量分离完成之后，CV数组中的指针指向了新copy出来的数据，而通过zend_execute_data-&gt;Ts中的指针则依然可以获取旧的数据。<br><strong>接下来的循环就不一一赘述了，结合上图来说：<br></strong><font style="COLOR: #ff0000">•foreach结构使用的是下方蓝色的array，会依次遍历a，b，c<br>•key、current使用的是上方黄色的array，它的内部指针永远指向b<br></font>至此我们明白了为何key和current一直返回array的第二个元素，由于没有外部代码作用于copy出来的array，它的内部指针便永远不会移动。<br><strong>问题3：<br></strong><div class="codetitle"> 代码如下:</div><code class="codebody" id="code51079"><br>$arr = array('a','b','c');<br>foreach($arr as $k =&gt; &amp;$v) {<br>&nbsp;&nbsp;&nbsp; echo key($arr), '=&gt;', current($arr);<br>}// 打印 1=&gt;b 2=&gt;c =&gt;<br></code><br><font style="COLOR: #ff0000">本题与问题2仅有一点区别：本题中的foreach使用了引用。</font>用VLD查看本题，发现与问题2代码编译出来的opcode一样。因此我们采用问题2的跟踪方法，逐步查看opcode对应的实现。<br><strong>首先foreach会调用FE_RESET:<br></strong><div class="codetitle"> 代码如下:</div><code class="codebody" id="code26512"><br>static int ZEND_FASTCALL&nbsp; ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value &amp; ZEND_FE_RESET_VARIABLE) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 从CV中获取变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr_ptr = _get_zval_ptr_ptr_cv(&amp;opline-&gt;op1, EX(Ts), BP_VAR_R TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (array_ptr_ptr == NULL || array_ptr_ptr == &amp;EG(uninitialized_zval_ptr)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 针对遍历array的情况<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value &amp; ZEND_FE_FETCH_BYREF) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将保存array的zval设置为is_ref<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_ISREF_PP(array_ptr_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr = *array_ptr_ptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_ADDREF_P(array_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; ……<br>}<br></code><br><font style="COLOR: #ff0000">问题2中已经分析了一部分FE_RESET的实现。</font>这里需要特别注意，本例foreach获取值采用了引用，因此在执行的时候FE_RESET中会进入与上题不同的另一个分支。<br>最终，FE_RESET会将array的is_ref设置为true，此时内存中只有一份array的数据。<br><strong>接下来分析SEND_REF：<br></strong><div class="codetitle"> 代码如下:</div><code class="codebody" id="code213"><br>static int ZEND_FASTCALL&nbsp; ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; // 从CV中获取$arr指针的指针<br>&nbsp;&nbsp;&nbsp; varptr_ptr = _get_zval_ptr_ptr_cv(&amp;opline-&gt;op1, EX(Ts), BP_VAR_W TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp; ……<br><br>&nbsp;&nbsp;&nbsp; // 变量分离，由于此时CV中的变量本身就是一个引用，此处不会copy一份新的array<br>&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);<br>&nbsp;&nbsp;&nbsp; varptr = *varptr_ptr;<br>&nbsp;&nbsp;&nbsp; Z_ADDREF_P(varptr);<br><br>&nbsp;&nbsp;&nbsp; // 压栈<br>&nbsp;&nbsp;&nbsp; zend_vm_stack_push(varptr TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp; ZEND_VM_NEXT_OPCODE();<br>}<br></code><br>宏SEPARATE_ZVAL_TO_MAKE_IS_REF仅仅分离is_ref=false的变量。由于之前array已经被设置了is_ref=true，因此它不会被拷贝一份副本。换句话说，此时内存中依然只有一份array数据。<p></p>
<p><img alt="" src="images/10/201306300929568.png" width="578" height="295"></p>
<p>上图解释了前2次循环为何会输出1=&gt;b 2=&gt;C。在第3次循环FE_FETCH的时候，将指针继续向前移动。<br></p><div class="codetitle"> 代码如下:</div><code class="codebody" id="code52552"><br>ZEND_API int zend_hash_move_forward_ex(HashTable *ht, HashPosition *pos)<br>{<br>&nbsp;&nbsp;&nbsp; HashPosition *current = pos ? pos : &amp;ht-&gt;pInternalPointer;<br>&nbsp;&nbsp;&nbsp; IS_CONSISTENT(ht);<br>&nbsp;&nbsp;&nbsp; if (*current) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *current = (*current)-&gt;pListNext;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SUCCESS;<br>&nbsp;&nbsp;&nbsp; } else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FAILURE;<br>}<br></code><br>由于此时内部指针已经指向了数组的最后一个元素，因此再向前移动会指向NULL。将内部指针指向NULL之后，我们再对数组调用key和current，则分别会返回NULL和false，表示调用失败，此时是echo不出字符的。<br><strong>&nbsp;问题4：<br></strong><div class="codetitle"> 代码如下:</div><code class="codebody" id="code95536"><br>$arr = array(1, 2, 3);<br>$tmp = $arr;<br>foreach($tmp as $k =&gt; &amp;$v){<br>&nbsp;&nbsp;&nbsp; $v *= 2;<br>}<br>var_dump($arr, $tmp); // 打印什么？<br></code><br>该题与foreach关系不大，不过既然涉及到了foreach，就一起拿来讨论吧:)<br>代码里首先创建了数组$arr，随后将该数组赋给了$tmp，在接下来的foreach循环中，对$v进行修改会作用于数组$tmp上，但是却并不作用到$arr。<br><strong>为什么呢?<br></strong>这是由于在php中，赋值运算是将一个变量的值拷贝到另一个变量中，因此修改其中一个，并不会影响到另一个。<br>题外话：这并不适用于object类型，从PHP5起，对象的便总是默认通过引用进行赋值，举例来说：<br><div class="codetitle"> 代码如下:</div><code class="codebody" id="code19699"><br>class A{<br>&nbsp;&nbsp;&nbsp; public $foo = 1;<br>}<br>$a1 = $a2 = new A;<br>$a1-&gt;foo=100;<br>echo $a2-&gt;foo; // 输出100，$a1与$a2其实为同一个对象的引用<br></code><br>回到题目中的代码，现在我们可以确定$tmp=$arr其实是值拷贝，整个$arr数组会被再复制一份给$tmp。理论上讲，赋值语句执行完毕之后，内存中会有2份一样的数组。<br>也许有同学会疑问，如果数组很大，岂不是这种操作会很慢？<br>幸好php有更聪明的处理办法。实际上，当$tmp=$arr执行之后，内存中依然只有一份array。查看php源码中的zend_assign_to_variable实现（摘自php5.3.26）：<br><div class="codetitle"> 代码如下:</div><code class="codebody" id="code47211"><br>static inline zval* zend_assign_to_variable(zval **variable_ptr_ptr, zval *value, int is_tmp_var TSRMLS_DC)<br>{<br>&nbsp;&nbsp;&nbsp; zval *variable_ptr = *variable_ptr_ptr;<br>&nbsp;&nbsp;&nbsp; zval garbage;<br>&nbsp;&nbsp;&nbsp; ……<br>　　// 左值为object类型<br>&nbsp;&nbsp;&nbsp; if (Z_TYPE_P(variable_ptr) == IS_OBJECT &amp;&amp; Z_OBJ_HANDLER_P(variable_ptr, set)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // 左值为引用的情况<br>&nbsp;&nbsp;&nbsp; if (PZVAL_IS_REF(variable_ptr)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左值refcount__gc=1的情况<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Z_DELREF_P(variable_ptr)==0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GC_ZVAL_CHECK_POSSIBLE_ROOT(*variable_ptr_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 非临时变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_tmp_var) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PZVAL_IS_REF(value) &amp;&amp; Z_REFCOUNT_P(value) &gt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOC_ZVAL(variable_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *variable_ptr_ptr = variable_ptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *variable_ptr = *value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_REFCOUNT_P(variable_ptr, 1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zval_copy_ctor(variable_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // $tmp=$arr会运行到这里，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // value为指向$arr里实际array数据的指针，variable_ptr_ptr为$tmp里指向数据指针的指针<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 仅仅是复制指针，并没有真正拷贝实际的数组<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *variable_ptr_ptr = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // value的refcount__gc值+1，本例中refcount__gc为1，Z_ADDREF_P之后为2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_ADDREF_P(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_UNSET_ISREF_PP(variable_ptr_ptr);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return *variable_ptr_ptr;<br>}<br></code><br>可见$tmp = $arr的本质就是将array的指针进行复制，然后将array的refcount自动加1.用图表达出此时的内存，依然只有一份array数组：<br><img alt="" src="images/10/20130630094752.png"><br>既然只有一份array，那foreach循环中修改$tmp的时候，为何$arr没有跟着改变？<br>继续看PHP源码中的ZEND_FE_RESET_SPEC_CV_HANDLER函数，这是一个OPCODE HANDLER，它对应的OPCODE为FE_RESET。该函数负责在foreach开始之前，将数组的内部指针指向其第一个元素。<br><div class="codetitle"> 代码如下:</div><code class="codebody" id="code11558"><br>static int ZEND_FASTCALL&nbsp; ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br>{<br>&nbsp;&nbsp;&nbsp; zend_op *opline = EX(opline);<br>&nbsp;&nbsp;&nbsp; zval *array_ptr, **array_ptr_ptr;<br>&nbsp;&nbsp;&nbsp; HashTable *fe_ht;<br>&nbsp;&nbsp;&nbsp; zend_object_iterator *iter = NULL;<br>&nbsp;&nbsp;&nbsp; zend_class_entry *ce = NULL;<br>&nbsp;&nbsp;&nbsp; zend_bool is_empty = 0;<br>&nbsp;&nbsp;&nbsp; // 对变量进行FE_RESET<br>&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value &amp; ZEND_FE_RESET_VARIABLE) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr_ptr = _get_zval_ptr_ptr_cv(&amp;opline-&gt;op1, EX(Ts), BP_VAR_R TSRMLS_CC);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (array_ptr_ptr == NULL || array_ptr_ptr == &amp;EG(uninitialized_zval_ptr)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // foreach一个object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 本例会进入该分支<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注意此处的SEPARATE_ZVAL_IF_NOT_REF<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 它会重新复制一个数组出来<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 真正分离$tmp和$arr，变成了内存中的2个数组<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value &amp; ZEND_FE_FETCH_BYREF) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_ISREF_PP(array_ptr_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr = *array_ptr_ptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_ADDREF_P(array_ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // 重置数组内部指针<br>&nbsp;&nbsp;&nbsp; ……<br>}<br></code><br>从代码中可以看出，真正执行变量分离并不是在赋值语句执行的时候，而是推迟到了使用变量的时候，这也是Copy On Write机制在PHP中的实现。<br>FE_RESET之后，内存的变化如下：<br><img alt="" src="images/10/20130630095123.png"><br><br>上图解释了为何foreach并不会对原来的$arr产生影响。至于ref_count以及is_ref的变化情况，感兴趣的同学可以详细阅读ZEND_FE_RESET_SPEC_CV_HANDLER和ZEND_SWITCH_FREE_SPEC_VAR_HANDLER的具体实现（均位于php-src/zend/zend_vm_execute.h中），本文不做详细剖析:)<br><p></p>
转自：<a href="http://www.jb51.net/article/39299.htm" target="_blank">http://www.jb51.net/article/39299.htm</a>
</div>
</section>